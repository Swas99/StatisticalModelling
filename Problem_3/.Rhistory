confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~. ,data = x, family = binomial())
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.GoodForKids  + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~. ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
fit_glm <-  glm(x$is_open~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.GoodForKids  + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot ,data = x, family = binomial())
nlevels(factor(x$is_open))
summary(fit_glm)
plot(fit_glm)
# Use your model to make predictions, in this example newdata = training set, but replace with your test set
pdata <- predict(fit_glm, newdata = x, type = "response")
nlevels(factor( as.numeric(pdata>0.5)))
nlevels(factor(x$is_open))
# use caret and compute a confusion matrix
confusionMatrix(data = factor(as.numeric(pdata>0.5)), reference = factor(x$is_open))
plot(fit, what = "BIC")
fit_mcmc_logit$BIC
fit_glm$BIC
plot(fit, what = "BIC")
fit_glm$aic
fit_glm$aic
fit_glm$control$trace
fit_glm$R
fit$
plot(fit, what = "BIC")
fit$BIC
fit$data
fit_mcmc_logit$bic
acf(fit_mcmc_logit)
fit$BIC
fit_glm$aic
fit_glm$bic
fit_glm$BIC
plot(fit, what = "BIC")
plot(fit_glm, what = "BIC")
plot(fit_glm, what = "AIC")
plot(fit_glm, what = "aic")
fit_glm$aic
plot(fit_glm, what = "BIC")
fit_RF <-  randomForest(factor(x$is_open) ~ ., data = x)
fit_RF <-  randomForest(factor(x$is_open) ~ x$review_count + x$attributes.Caters + x$attributes.WiFi + x$attributes.BikeParking + x$attributes.Ambience.casual + x$hours.Monday + x$hours.Sunday + x$stars + x$attributes.RestaurantsDelivery + x$attributes.RestaurantsTakeOut, data = x)
plot(fit_RF)
print(fit_RF)
varImpPlot(fit_RF,
sort = T,
n.var=10,
main="Top 10 - Variable Importance")
var.imp = data.frame(importance(fit_RF,
type=2))
var.imp$Variables = row.names(var.imp)
print(var.imp[order(var.imp$MeanDecreaseGini,decreasing = T),])
df_toronto_2_test
y2 = predict(fit_RF,x )
confusionMatrix(data = y2, reference = factor(x$is_open))
fit_RF <-  randomForest(factor(x$is_open) ~ x$review_count + x$attributes.Caters + x$attributes.WiFi + x$attributes.BikeParking + x$attributes.Ambience.casual + x$hours.Monday + x$hours.Sunday + x$stars + x$attributes.RestaurantsDelivery + x$attributes.RestaurantsTakeOut, data = x)
confusionMatrix(data = predict(fit_RF,x ), reference = factor(x$is_open))
fit_RF <-  randomForest(factor(x$is_open) ~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot, data = x)
fit_RF <-  randomForest(factor(x$is_open) ~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot, data = x)
confusionMatrix(data = predict(fit_RF,x ), reference = factor(x$is_open))
fit_RF <-  randomForest(factor(x$is_open) ~ x$review_count + x$attributes.Caters + x$attributes.WiFi + x$attributes.BikeParking + x$attributes.Ambience.casual + x$hours.Monday + x$hours.Sunday + x$stars + x$attributes.RestaurantsDelivery + x$attributes.RestaurantsTakeOut, data = x)
confusionMatrix(data = predict(fit_RF,x ), reference = factor(x$is_open))
fit_RF <-  randomForest(factor(x$is_open) ~ x$stars + x$review_count + x$attributes.BusinessAcceptsCreditCards + x$attributes.WheelchairAccessible + x$attributes.Caters + x$attributes.WiFi + x$attributes.RestaurantsTakeOut + x$attributes.RestaurantsTableService + x$attributes.OutdoorSeating + x$attributes.RestaurantsDelivery + x$attributes.BikeParking + x$attributes.HappyHour + x$attributes.BusinessParking.street + x$attributes.GoodForMeal.dessert  + x$attributes.GoodForMeal.breakfast + x$attributes.GoodForMeal.brunch + x$attributes.BusinessParking.lot, data = x)
confusionMatrix(data = predict(fit_RF,x ), reference = factor(x$is_open))
compare_m_gibbs <- function(y, ind, maxiter = 5000)
{
### weakly informative priors
a0 <- 1/2 ; b0 <- 50 ## tau_w hyperparameters
eta0 <-1/2 ; t0 <- 50 ## tau_b hyperparameters
mu0<-50 ; gamma0 <- 1/25
###
a0 <- 1.9 ; b0 <- 1 ## tau_w hyperparameters
eta0 <-1/2 ; t0 <- 5 ## tau_b hyperparameters
mu0<-3.5 ; gamma0 <- 1.25
###
### starting values
m <- nlevels(ind)
ybar <- theta <- tapply(y, ind, mean)
temp = tapply(y, ind, var)
temp = temp[!is.na(temp)]
tau_w <- 1/mean(temp) ##within group precision
mu <- mean(theta)
tau_b <-var(theta) ##between group precision
n_m <- tapply(y, ind, length)
an <- a0 + sum(n_m)/2
###
### setup MCMC
theta_mat <- matrix(0, nrow=maxiter, ncol=m)
mat_store <- matrix(0, nrow=maxiter, ncol=3)
###
### MCMC algorithm
for(s in 1:maxiter)
{
# sample new values of the thetas
for(j in 1:m)
{
taun <- n_m[j] * tau_w + tau_b
thetan <- (ybar[j] * n_m[j] * tau_w + mu * tau_b) / taun
theta[j]<-rnorm(1, thetan, 1/sqrt(taun))
}
#sample new value of tau_w
ss <- 0
for(j in 1:m){
ss <- ss + sum((y[ind == j] - theta[j])^2)
}
bn <- b0 + ss/2
tau_w <- rgamma(1, an, bn)
#sample a new value of mu
gammam <- m * tau_b + gamma0
mum <- (mean(theta) * m * tau_b + mu0 * gamma0) / gammam
mu <- rnorm(1, mum, 1/ sqrt(gammam))
# sample a new value of tau_b
etam <- eta0 + m/2
tm <- t0 + sum((theta-mu)^2)/2
tau_b <- rgamma(1, etam, tm)
#store results
theta_mat[s,] <- theta
mat_store[s, ] <- c(mu, tau_w, tau_b)
}
colnames(mat_store) <- c("mu", "tau_w", "tau_b")
return(list(params = mat_store, theta = theta_mat))
}
library(zoo)
library(httr)
library(readr)
library(ggpubr)
library(plotly)
library(mclust)
library(ggplot2)
library(reshape)
library(stringr)
library(MCMCpack)
library(BayesLCA)
library(jsonlite)
library(tidyverse)
#install.packages("ggpubr")
##Business_Toronto_Restaurant.json
path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/Business_Toronto_Restaurant.json"
df_toronto <- stream_in(file(path), flatten = TRUE)
#path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/_all/business.json"
#df_original <- stream_in(file(path))
#df_toronto <- flatten(df_toronto)
#df_toronto$neighborhood
df_indian <- df_toronto[str_detect(df_toronto$categories, "India|india|INDIA"),]
nrow(df_indian)
df_indian_open <- df_indian[df_indian$is_open == 1,]
df_indian_open_min_4review <- df_indian_open[df_indian_open$review_count > 3,]
df_ek_indian <- df_indian[df_indian$neighborhood == "Etobicoke",]
df_sb_indian <- df_indian[df_indian$neighborhood == "Scarborough",]
df_ek_indian_open_min_4review <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Etobicoke",]
df_sb_indian_open_min_4review <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Scarborough",]
df_indian_open_min_4review$neighborhood <- factor(df_indian_open_min_4review$neighborhood)
nlevels(df_indian_open_min_4review$neighborhood)
df_indian_open_min_4review$neighborhood <- as.numeric(df_indian_open_min_4review$neighborhood)
nrow(df_indian_open)
nrow(df_indian_open_min_4review)
nrow(df_ek_indian)
nrow(df_sb_indian)
nrow(df_ek_indian_open_min_4review)
nrow(df_sb_indian_open_min_4review)
mean(df_indian_open_min_4review$stars)
mean(df_ek_indian_open_min_4review$stars)
mean(df_sb_indian_open_min_4review$stars)
mean(df_ek_indian$stars)
mean(df_sb_indian$stars)
df_ek_indian$business_id
x <- df_indian_open_min_4review[df_indian_open_min_4review$business_id == "ZPhQyUO9MY5xNEcTqZOrTQ",]
x
ggplot(df_ek_indian) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=TRUE)
ggplot(df_sb_indian) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=TRUE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Scarborough" | df_indian_open_min_4review$neighborhood == "Etobicoke",]) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
ggplot(df_indian_open_min_4review) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
#stars Vs count
ggplot(df_sb_indian_open_min_4review, aes(stars)) + stat_bin()
#stars Vs count
ggplot(df_ek_indian_open_min_4review, aes(stars)) + stat_bin()
# neighbourhood vs count
ggplot(df_indian_open_min_4review, aes(x = reorder(neighborhood, neighborhood, length))) + stat_count()
df2 <- df_indian_open_min_4review[df_indian_open_min_4review$business_id %in% c("OGSWuGLLW_8TBmQ_wWhdEQ","YLeAUkFFJri_21uTkyrVFg"),]
df2
df2 <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood %in% c(14,33),]
#Etobicoke : 14
#Scarborough : 33
fit_1 <- compare_m_gibbs(df2$stars, factor(df2$neighborhood))
#fit_1 <- compare_m_gibbs(df_indian_open_min_4review$stars, factor(df_indian_open_min_4review$neighborhood))
apply(fit_1$params, 2, mean)
apply(fit_1$params, 2, sd)
mean(1/sqrt(fit_1$params[, 3]))
sd(1/sqrt(fit_1$params[, 3]))
theta_hat <- apply(fit_1$theta, 2, mean)
ggplot(data.frame(size = tapply(df_indian_open_min_4review$stars, df_indian_open_min_4review$neighborhood, length), theta_hat = theta_hat), aes(size, theta_hat)) + geom_point()
#Normality tests
#p-value > 0.05 implies that we can assume the normality.
shapiro.test(rnorm(100, mean = 5, sd = 3))
shapiro.test(runif(100, min = 2, max = 4))
#Bell Shape == Normal distribution
ggdensity(rnorm(100, mean = 5, sd = 3),
main = "Density plot of ratings",
xlab = "Ratings")
#If points are close to the 45 degree line -> normal distribution
ggqqplot(rnorm(100, mean = 5, sd = 3))
shapiro.test(df_ek_indian_open_min_4review$stars)
ggdensity(df_indian_open_min_4review$stars,
main = "Density plot of ratings",
xlab = "Ratings")
ggqqplot(df_ek_indian_open_min_4review$stars)
df3 <- df1[df1$business_id %in% businessIds,]
varImpPlot(fit_RF, sort = T, n.var=10, main="Top 10 - Variable Importance")
path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/Business_Toronto_Restaurant.json"
df_bus_TO <- stream_in(file(path))
df_bus_TO <- stream_in(file(path))
df_bus_TO <- flatten(df_bus_TO)
df_bus_TO$neighborhood <- factor(df_bus_TO$neighborhood)
nlevels(df_bus_TO$neighborhood)
df_bus_TO$neighborhood <- as.numeric(df_bus_TO$neighborhood)
df_bus_TO = df_bus_TO[!(df_bus_TO$neighborhood ==38),]
df_bus_TO = df_bus_TO[!(df_bus_TO$neighborhood ==38),]
df_bus_TO$neighborhood <- as.numeric(df_bus_TO$neighborhood)
df_bus_TO = df_bus_TO[!(df_bus_TO$neighborhood ==38),]
df_bus_TO <- flatten(df_bus_TO)
df_bus_TO$neighborhood <- factor(df_bus_TO$neighborhood)
nlevels(df_bus_TO$neighborhood)
df_bus_TO$neighborhood <- as.numeric(df_bus_TO$neighborhood)
df_bus_TO = df_bus_TO[!(df_bus_TO$neighborhood ==38),]
compare_m_gibbs <- function(y, ind, maxiter = 5000)
{
### weakly informative priors
a0 <- 1/2 ; b0 <- 50 ## tau_w hyperparameters
eta0 <-1/2 ; t0 <- 50 ## tau_b hyperparameters
mu0<-50 ; gamma0 <- 1/25
###
a0 <- 1.9 ; b0 <- 1 ## tau_w hyperparameters
eta0 <-1/2 ; t0 <- 5 ## tau_b hyperparameters
mu0<-3.5 ; gamma0 <- 1.25
###
### starting values
m <- nlevels(ind)
ybar <- theta <- tapply(y, ind, mean)
temp = tapply(y, ind, var)
temp = temp[!is.na(temp)]
tau_w <- 1/mean(temp) ##within group precision
mu <- mean(theta)
tau_b <-var(theta) ##between group precision
n_m <- tapply(y, ind, length)
an <- a0 + sum(n_m)/2
###
### setup MCMC
theta_mat <- matrix(0, nrow=maxiter, ncol=m)
mat_store <- matrix(0, nrow=maxiter, ncol=3)
###
### MCMC algorithm
for(s in 1:maxiter)
{
# sample new values of the thetas
for(j in 1:m)
{
taun <- n_m[j] * tau_w + tau_b
thetan <- (ybar[j] * n_m[j] * tau_w + mu * tau_b) / taun
theta[j]<-rnorm(1, thetan, 1/sqrt(taun))
}
#sample new value of tau_w
ss <- 0
for(j in 1:m){
ss <- ss + sum((y[ind == j] - theta[j])^2)
}
bn <- b0 + ss/2
tau_w <- rgamma(1, an, bn)
#sample a new value of mu
gammam <- m * tau_b + gamma0
mum <- (mean(theta) * m * tau_b + mu0 * gamma0) / gammam
mu <- rnorm(1, mum, 1/ sqrt(gammam))
# sample a new value of tau_b
etam <- eta0 + m/2
tm <- t0 + sum((theta-mu)^2)/2
tau_b <- rgamma(1, etam, tm)
#store results
theta_mat[s,] <- theta
mat_store[s, ] <- c(mu, tau_w, tau_b)
}
colnames(mat_store) <- c("mu", "tau_w", "tau_b")
return(list(params = mat_store, theta = theta_mat))
}
library(zoo)
library(httr)
library(readr)
library(ggpubr)
library(plotly)
library(mclust)
library(ggplot2)
library(reshape)
library(stringr)
library(MCMCpack)
library(BayesLCA)
library(jsonlite)
library(tidyverse)
#install.packages("ggpubr")
##Business_Toronto_Restaurant.json
path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/Business_Toronto_Restaurant.json"
df_toronto <- stream_in(file(path), flatten = TRUE)
#path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/_all/business.json"
#df_original <- stream_in(file(path))
#df_toronto <- flatten(df_toronto)
#df_toronto$neighborhood
df_indian <- df_toronto[str_detect(df_toronto$categories, "India|india|INDIA"),]
nrow(df_indian)
df_indian_open <- df_indian[df_indian$is_open == 1,]
df_indian_open_min_4review <- df_indian_open[df_indian_open$review_count > 3,]
df_ek_indian <- df_indian[df_indian$neighborhood == "Etobicoke",]
df_sb_indian <- df_indian[df_indian$neighborhood == "Scarborough",]
df_ek_indian_open_min_4review <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Etobicoke",]
df_sb_indian_open_min_4review <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Scarborough",]
df_indian_open_min_4review$neighborhood <- factor(df_indian_open_min_4review$neighborhood)
nlevels(df_indian_open_min_4review$neighborhood)
df_indian_open_min_4review$neighborhood <- as.numeric(df_indian_open_min_4review$neighborhood)
nrow(df_indian_open)
nrow(df_indian_open_min_4review)
nrow(df_ek_indian)
nrow(df_sb_indian)
nrow(df_ek_indian_open_min_4review)
nrow(df_sb_indian_open_min_4review)
mean(df_indian_open_min_4review$stars)
mean(df_ek_indian_open_min_4review$stars)
mean(df_sb_indian_open_min_4review$stars)
mean(df_ek_indian$stars)
mean(df_sb_indian$stars)
x <- df_indian_open_min_4review[df_indian_open_min_4review$business_id == "ZPhQyUO9MY5xNEcTqZOrTQ",]
ggplot(df_ek_indian) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=TRUE)
ggplot(df_sb_indian) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=TRUE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Scarborough" | df_indian_open_min_4review$neighborhood == "Etobicoke",]) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
ggplot(df_indian_open_min_4review) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
ggplot(df_indian_open_min_4review) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE) +
geom_violin()
ggplot(df_indian_open_min_4review) + +
geom_violin()
ggplot(df_indian_open_min_4review) + geom_violin()
# neighbourhood vs count
ggplot(df_indian_open_min_4review, aes(x = reorder(neighborhood, neighborhood, length))) + stat_count()
df2 <- df_indian_open_min_4review[df_indian_open_min_4review$business_id %in% c("OGSWuGLLW_8TBmQ_wWhdEQ","YLeAUkFFJri_21uTkyrVFg"),]
df2 <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood %in% c(14,33),]
ggplot(data.frame(size = tapply(df_indian_open_min_4review$stars, df_indian_open_min_4review$neighborhood, length), theta_hat = theta_hat), aes(size, theta_hat)) + geom_point()
df2 <- df_indian_open_min_4review[df_indian_open_min_4review$neighborhood %in% c(14,33),]
#Etobicoke : 14
#Scarborough : 33
fit_1 <- compare_m_gibbs(df2$stars, factor(df2$neighborhood))
#fit_1 <- compare_m_gibbs(df_indian_open_min_4review$stars, factor(df_indian_open_min_4review$neighborhood))
apply(fit_1$params, 2, mean)
apply(fit_1$params, 2, sd)
mean(1/sqrt(fit_1$params[, 3]))
sd(1/sqrt(fit_1$params[, 3]))
theta_hat <- apply(fit_1$theta, 2, mean)
ggplot(data.frame(size = tapply(df_indian_open_min_4review$stars, df_indian_open_min_4review$neighborhood, length), theta_hat = theta_hat), aes(size, theta_hat)) + geom_point()
ggplot(df_indian_open_min_4review, aes(x = neighborhood, y = stars)) +
geom_violin()
geom_violin(aes(x = reorder(neighborhood, stars, median))
ggplot(df_indian_open_min_4review, aes(x = neighborhood, y = stars)) +
ggplot(df_indian_open_min_4review, aes(x = neighborhood, y = stars)) +
geom_violin(aes(x = reorder(neighborhood, stars, median), stars))
ggplot(df_indian_open_min_4review[], aes(x = neighborhood, y = stars)) +
geom_violin(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)))
ggplot(df_indian_open_min_4review[], aes(x = neighborhood, y = stars)) +
geom_violin(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend = FALSE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood = 33|df_indian_open_min_4review$neighborhood = 14,], aes(x = neighborhood, y = stars)) +
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == 33|df_indian_open_min_4review$neighborhood == 14,], aes(x = neighborhood, y = stars)) +
geom_violin(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend = FALSE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == "Scarborough" | df_indian_open_min_4review$neighborhood == "Etobicoke",]) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == 14 | df_indian_open_min_4review$neighborhood == 33,]) + geom_boxplot(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend=FALSE)
ggplot(df_indian_open_min_4review[df_indian_open_min_4review$neighborhood == 33|df_indian_open_min_4review$neighborhood == 14,], aes(x = neighborhood, y = stars)) +
geom_violin(aes(x = reorder(neighborhood, stars, median), stars, fill = reorder(neighborhood, stars, median)), show.legend = FALSE)
library(zoo)
library(httr)
library(readr)
library(caret)
library(ggpubr)
library(plotly)
library(mclust)
library(ggplot2)
library(reshape)
library(stringr)
library(MCMCpack)
library(BayesLCA)
library(jsonlite)
library(tidyverse)
library(xgboost)
library(party)
library(randomForest)
#install.packages("xgboost")
##Business_Toronto_Restaurant.json
path = "C:/Users/Swastik/Desktop/MastersDegree_CS/Semester_2/AppliedStatisticalModelling/ass_2/data/Business_Toronto_Restaurant.json"
df_toronto   <- stream_in(file(path), flatten = TRUE)
#Keep only Restaurants
df_toronto_2 <- df_toronto[str_detect(df_toronto$categories, "Restaurants|restaurant"),]
#Mark all operating day with a single value
df_toronto_2$hours.Sunday[!is.na(df_toronto_2$hours.Sunday)] <- 99
df_toronto_2$hours.Monday[!is.na(df_toronto_2$hours.Monday)] <- 99
df_toronto_2$hours.Tuesday[!is.na(df_toronto_2$hours.Tuesday)] <- 99
df_toronto_2$hours.Wednesday[!is.na(df_toronto_2$hours.Wednesday)] <- 99
df_toronto_2$hours.Thursday[!is.na(df_toronto_2$hours.Thursday)] <- 99
df_toronto_2$hours.Friday[!is.na(df_toronto_2$hours.Friday)] <- 99
df_toronto_2$hours.Saturday[!is.na(df_toronto_2$hours.Saturday)] <- 99
#Replace NA
df_toronto_2[is.na(df_toronto_2)] <- -1
#respresent categorical variables used in regression as numeric factors
df_toronto_2[,3] <- as.numeric(factor(df_toronto_2[,3]))
for(i in 7:9)#9 can be changed to 9->10 here
df_toronto_2[,i] <- as.numeric(factor(df_toronto_2[,i]))
for(i in 14:93)
df_toronto_2[,i] <- as.numeric(factor(df_toronto_2[,i]))
#Check for single-valued cols
for(i in 1:93)
{
if(length(( unique( df_toronto_2[,i]) )) > 2)
{
#print(colnames(df_toronto_2)[i])
#print(length(( unique( df_toronto_2[,i]) )))
}
}
x3 <- df_toronto
X <- data.frame(x3$is_open)
X["attributes.Alcohol"] <- x3$attributes.Alcohol
X["attributes.WiFi"] <- x3$attributes.WiFi
X["attributes.WiFi"] <- x3$attributes.WiFi
unique(X$attributes.Caters)
X["attributes.Caters"] <- x3$attributes.Caters
x3$attributes.Caters
X$attributes.Caters
unique(X$attributes.Caters)
x3 <- df_toronto
X <- data.frame(x3$is_open)
X["attributes.Alcohol"] <- x3$attributes.Alcohol
X["attributes.WiFi"] <- x3$attributes.WiFi
X["attributes.Caters"] <- x3$attributes.Caters
X["good_rating"] <- x3$stars
X$attributes.Caters
X$attributes.Alcohol[X$attributes.Alcohol == "full_bar"] <- 1
X$attributes.Alcohol[X$attributes.Alcohol == "beer_and_wine"] <- 1
X$attributes.Alcohol[X$attributes.Alcohol != 1] <- 0
X$attributes.WiFi[X$attributes.WiFi == "free"] <- 1
X$attributes.WiFi[X$attributes.WiFi != 1] <- 0
X$good_rating[X$stars < 4 ] <- 0
X$good_rating[X$stars != 0] <- 1
X$good_rating[is.na(X$good_rating)] <- 0
X$attributes.WiFi[is.na(X$attributes.WiFi)] <- 0
X$attributes.Caters[is.na(X$attributes.Caters)] <- 0
X$attributes.Alcohol[is.na(X$attributes.Alcohol)] <- 0
X$good_rating <- as.numeric(X$good_rating)
X$attributes.WiFi <- as.numeric(X$attributes.WiFi)
X$attributes.Caters <- as.numeric(X$attributes.Caters)
X$attributes.Alcohol <- as.numeric(X$attributes.Alcohol)
unique(X$x3.is_open)
unique(X$good_rating)
unique(X$attributes.WiFi)
unique(X$attributes.Caters)
unique(X$attributes.Alcohol)
X$good_rating[X$good_rating < 4.0 ] <- 0
X$good_rating[X$good_rating != 0] <- 1
unique(X$good_rating)
apply(X, 2, mean)
barplot(apply(X, 2, mean))
fit_lca <- blca.em(X, 2, restarts = 2, verbose = FALSE)
print(fit_lca)
plot(fit_lca, which = 5)
